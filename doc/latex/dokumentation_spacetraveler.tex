\documentclass[12pt,a4paper]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{color}
\usepackage{graphicx}
\usepackage{listings}
\usepackage[left=2.5cm, right=2cm, top=2cm, bottom=2cm]{geometry}

\usepackage[hidelinks]{hyperref}
\usepackage{scrpage2}
\usepackage{csquotes}
\usepackage{subcaption}


\DeclareUnicodeCharacter{00A0}{ }

\pagestyle{scrheadings}


\linespread{1.5}
\setlength{\parindent}{0cm} % No paragraph indent


\newcommand{\q}[1]{``#1''}
\newcommand{\todo}[1]{\begin{Large}\textcolor{red}{$\Rightarrow ~$#1}\end{Large}}

\newcommand{\ant}[1]{\begin{Large}\textcolor{green}{$\Rightarrow ~$#1}\end{Large}}


\newcommand{\inmilestonetwo}{\vspace{0.75cm} \framebox[1.1\width]{
\begin{large}
\textcolor{red}{Die Dokumentation dieses Abschnittes ist für Milestone II vorgesehen.}
\end{large}}}



\begin{document}

\include{titelseite}

\clearpage

\tableofcontents

\clearpage

\todo{Informationen / Beispielarbeit beachten!}

\section{Projektbeschreibung}
\subsection{Spielidee}
Ziel unseres Spieles ist es, dass der Spieler sein Raumschiff von einer Startposition im Level
zum Ziel bringt. Dazu eine kleine Story:
\begin{quote}
Der verrückte Wissenschaftler Prof. Lewinsky war mit seiner Rakete auf der Suche nach einem äusserst seltenen Element welches er zur Fertigung seiner Gravitationskanone benötigt. 
In einer weit entfernten Galaxie wurde er Fündig. 
Beim Treibstoff hatte er sich jedoch verrechnet und stand nun ohne Antrieb am anderen Ende des Universums.
Glücklicherweise konnte er seine Gravitationskanone an Bord fertigstellen.
Deine Aufgabe ist es nun Prof. Lewinsky mithilfe der instabilen und ungetesteten Gravitationskanone nach Hause zu befördern. 
Dabei musst du auf die herumfliegenden Asteroiden achtgeben. 
Vor allem solltest du dich jedoch vor den abnormal kleinen Schwarzen Löchern in Acht nehmen, die nur in diesem Teil des Universums vorkommen und dich sofort anziehen, wenn du ihnen zu nahe kommst. 
Hilf dem hoffnungslosen Theoretiker nach Hause zu kommen!
\end{quote}

\subsection{Physik}
In unserem Spiel haben wir einige Elemente der Physik der realen Welt übernommen.
Dabei handelt es sich nur schon um Geschwindigkeit, Beschleunigung und Kräfte.
Dazu haben wir auch die Gravitation und den elastischen Stoss, als komplexere Vorgänge modelliert.
\subsubsection{Geschwindigkeit, Beschleunigung, Kraft}
Unser Spieler bewegt sich im Level.
Hier ist bereits die Sprache von Geschwindigkeit.
Zur Geschwindigkeit ist wohl keine Erklärung nötig.
Dazu kommt die Beschleunigung, die man als zeitliche Änderung der Geschwindigkeit auffassen kann.
Wichtig zu verstehen ist jedoch der Zusammenhang zwischen Kraft und Beschleunigung.
Um Kräfte zu berechnen nimmt man das Produkt aus Beschleunigung und Masse.
Also ist die Beschleunigung, wenn die Kraft bekannt ist, auch von dem Faktor Masse abhängig. ...

\subsection{Gravitation}
Unter Gravitation versteht man in der Physik, die Anziehngskraft, mit der sich Masse anzieht.
Bekannt ist uns die Gravitation von den Planeten und ihren Anziehungskräften.
Die Sonne zieht mit ihrer enormen Masse die Planeten an und die Planeten ziehen die Monde an.
Auf der Erde zeigt sich Gravitation als Schwerkraft, die uns am Boden hält.
Dies kommt davon, dass die Erde sehr viel grösser als wir ist.
Im Sonnensystem jedoch findet Gravitation zwischen Objekten ähnlicher Grösse statt.
Wenn sich ein Objekt einem anderen nähert gibt es drei Mögliche Auswirkungen.
\begin{enumerate}
\item Sie ziehen sich gegenseitig so an, dass sie miteinander kollidieren.
\item Sie sind schnell und lenken sich gegenseitig bei nahekommen einfach ab, entfernen sich danach jedoch zu weit um weiter Einfluss aufeinander zu bewirken.
\item 

\end{enumerate}


\subsection{Elastischer Stoss}
Im Spiel brauchen wir bei der Kollision der einzelnen Asteroiden und der Kollision mit der Wand das Prinzip des vollkommen elastischen Stosses. \\
In der realen Welt kommt es ständig zu Kollisionen, sei es ein Fuss, der auf einen Ball trifft, Billardkugeln die Kollidieren, oder zwei Autos bei einer Frontalkollision. 
Ständig stossen Objekte aufeinander. \\
Die Physik kennt verschiedene Arten solcher Stösse.
Unterschieden wird dabei, wie Energie übertragen wird.
Speziell im Bezug auf den Stoss sind das innere Energie und kinetische Energie.
Einfach gesagt unterscheidet man, ob sich Objekte bei einer Kollision verformen und/oder erhitzen, oder sie ihre Geschwindigkeit und Richtung ändern.\\
Die Extremfälle bilden also zum einen ein Stoss, bei dem Beide Objekte sofort still stehen und sich erwärmen oder deformieren.
Dies nennt man den vollkommen unelastischen Stoss.
Zum anderen ein Stoss, bei dem die Objekte keine Deformation oder Erwärmung erfahren, sondern eine Änderung der Geschwindigkeit und der Bewegungsrichtung stattfindet.
Dies nennt man den vollkommen elastischen Stoss.\\
Beide Fälle sind Idealfälle.
Sie kommen in der realen Welt nicht vor.
In unserem Spiel wollten wir einen beinahe vollkommen elastischen Stoss umsetzen.
\todo{langet da? wo selli da wege vektorfällig schriibe im andere teil denne?}
\ant{Jio, da wär gäbig...}




\section{Problemdefinition}
\subsection{Grundkriterien}
Wir haben uns folgende Grundkriterien gesetzt:
\begin{itemize}
\item Gravitation: Punkte, die den Spieler unterschiedlich stark gegen sich ziehen.
\item Der Spieler ist ein Raumschiff.
\item Der Spieler befindet sich in einem Raum fernab von jeder anderen Kraftquelle ausserhalb des Levels.
\item Der Spieler bewegt sich durch dieses Level mithilfe von  einem Gravitationspunkt, den er platzieren und entfernen kann; Er kann sich also \q{in eine Richtung ziehen lassen}
\item Das Level ist beschränkt, hat also einen Start und ein Ziel
\item Es gibt Wände, die den Raum beschränken.
\end{itemize}

\subsection{Zusatzkriterien}
Als Zusatzkriterien setzen wir uns weiter:
\begin{itemize}
\item Gegner und/oder Hindernisse (= Objekte bei deren Kollision der Spieler stirbt) z.B: Asteroiden die sich frei bewegen, oder sehr starke Gravitationszentren, die den Spieler gegen ein Objekt ziehen und so eine Kollision auslösen.
\item Gameover-Grafik, die angezeigt wird, wenn der Spieler stirbt oder die Zeit abläuft.
\item Es besteht eine kleine Reibung, die den Spieler leicht abbremst.
\item Zeitliche Beschränkung (z.B: 2min, wenn Zeit = 0, ist das Spiel zu Ende)
\item Startmenu und Spielanleitung
\end{itemize}




\section{Anforderungsanalyse}
% maximal 2 sätze, in java realisierbar
Das Programm lässt sich mitsamt seinen Anforderungen vollständig in Java implementieren.
Es werden auf Soft-/Hardwareebene keine weiteren Anforderungen gestellt, als ein einfacher Computer mit
Maus und funktionierender JRE.


\section{Spezifikation}
\subsection{Use Cases}
\todo{Weitere Usecases?}
\subsubsection{Spieler}
\includegraphics[scale=0.2]{use_cases/spieler.png}
\todo{Beschreibung ergänzen}


\subsubsection{spaceObject}
\includegraphics[scale=0.2]{use_cases/spaceObject.png}\\
Ein spaceObject kann von einem Actor (Gravitationspunkt) angezogen werden. Das spaceObject
\q{fliegt} aber jeder Zeit \q{herum}. Dazu braucht es keinen Actor.


\subsection{Anforderungen} 
\subsubsection{Technische Ausführung}
\begin{itemize}
\item Mit der Maus soll das Setzen eines Gravitationspunktes - und damit die Steuerung der Spielfigur - möglich sein.
\item Java packages: \begin{itemize}
	\item java.util.* \textit{(Datenstrukturen)}
	\item java.io.* \textit{(Um Daten aus dem .jar als Streams zu laden)}
\end{itemize}
\item JSFML packages: \begin{itemize}
	\item org.jsfml.Graphics.* \textit{(Grafik-API von JSFML)}
	\item ...
\end{itemize}
\end{itemize}
	%% technische ausführung

\subsection{Dokumentation}
Diese Dokumentation wurde in \LaTeX \,\, erstellt. Da die Rohdateien in LaTeX im Textformat und nicht
binär vorliegen konnten wir sie ebenfalls in unser Revisionskontrollsystem einbinden und parallel
an ihr schreiben.\\

Da wir unseren Code mit den entsprechenden Kommentaren ausgeschmückt haben,
konnten wir eine detaillierte Codedokumentation mit dem Programm \textit{doxygen} (ähnlich wie javadoc) erstellen lassen.
Die PDF-Datei, die dabei herauskam liess sich leicht an unsere Dokumentation anhängen.\\

Der Quellcode wurde über das \textit{listings}-Paket direkt von LaTeX selbst eingelesen und formatiert.

\subsubsection{Der Spieler ist ein Raumschiff}
Wie man in der Story lesen kann, dreht sich unser Spiel vollständig um den Wissenschaftler im Raumschiff. Eigentlich geht es nur um das Raumschiff, denn dieses muss man sicher ans Ziel bringen.
Um dieses Raumschiff zu erstellen, nutzten wir die JSFML Bibliotheken.	\\

Zuerst erstellen, skalieren und positionieren wir das Fenster auf den Zeilen 234-236 der Klasse Game.java.
Danach erstellen wir eine View.
Solch eine View kann man sich als eine Kamera vorstellen, die mobil ist und nur das anzeigt, was sie sieht.
Zuerst ist diese View default und hat die Dimensionen des Fensters.
In Zeile 541 setzen wir jedoch diese Kamera auf den Spieler.
Damit überhaupt etwas angezeigt werden kann, muss es gezeichnet werden. 
Die Klasse RenderWindow besitzt deshalb eine Methode draw(Drawable), die wir vor allem am Ende der Gameklasse aufrufen.
Mit dieser Methode wird das bestimmte Objekt der Art Drawable.
Es gibt viele Klassen in den JSFML-Bibliotheken, die von dieser Art sind.
Eine nutzten wir jedoch am Häufigsten: die Sprites.		\\
Die JSFML-Klasse Sprite ist sehr nützlich für Objekte, die sich bewegen und miteinander interagieren sollten.
Ein solches Sprite besteht einfach gesagt aus einem Texture mit dem Bild und einem Rechteck, welches oftmals die Dimensionen des Bides besitzt.
Unser Spieler besitzt auch ein solches Sprite.
Genauer noch ist unser Spieler ein SpaceObject.		
Die Klasse SpaceObject brauchen sowohl für das Raumschiff wie auch für die Asteroiden.		\\
Das Ganze Spiel basiert auf einer while-Schleife, die in Game.java in Zeile 313 beginnt.
Diese Schleife läuft solange das Fenster offen ist weiter.
Dadurch realisieren wir ein ständiges Fortlaufen des Spieles.
Zum Beispiel wird die vorher beschriebene Methode draw(Drawable) innerhalb dieser Schleife ausgeführt.
So werden die Texturen ständig aktualisiert und sichergestellt, dass keine Veränderungen stattfinden und nicht dargestellt werden.
Um nun den Spieler anzeigen zu lassen, rufen wir den Konstruktor der SpaceObjects auf und laden das Bild: 	\\

\begin{center}
\includegraphics[scale=1]{img/spieler.png}
\end{center}

Danach lassen wir das Sprite des SpaceObjects zeichnen.




\subsubsection{Raum frei von auswärtigen Kräften}
% kurze erläuterung


\subsubsection{Gravitation}
Im Spiel finden sich sogenannte Gravitationspunkte, die den Spieler unterschiedlich stark anziehen.
Um diese Punkte zu implementieren, mussten wir uns durch etwas Physikliteratur wälzen und entsprechende
Anpassungen vornehmen, um die Gravitation mit vertretbarem Programmier- und auch Rechenaufwand implementieren zu können.  \\

Unsere Gravitation stellt eine vereinfachte Simulation dar, die nicht ganz mit der Realität übereinstimmt.
So ziehen sich in der echten Welt Objekte gleichzeitig an, was zu komplizierten gekoppelten Gleichungen führt, während dies in
unserem Spiel vernachlässigt wird und die Anziehungswirkung sequentiell in kleinen Abständen berechnet wird.\\

Alle Objekte, auf die sich die Gravitation im Spiel auswirken kann (sog. spaceObjects), befinden sich in einer Liste (\textit{spaceObjects})
In einer äusseren Schleife werden alle Objekte durchiteriert, in der inneren Schleife werden die Auswirkungen jedes Gravitationspunktes berechnet und
das Objekt verschoben. In Pseudocode:
\begin{verbatim}
FÜR jedes objekt in spaceObjects:
    FÜR jeden punkt in objekt.gravitationsPunkte:
        objekt.addEnergy(punkt.getEnergy(objekt))
\end{verbatim}

wobei \textit{auswirkungen} ein (mathematischer) Vektor ist, der \q{Energieänderungen} in $x$- und $y$-Richtung angibt.
Da dies den rechnerischen Teil der Gravitationspunkte betrifft, findet sich die Implementierung in der \textit{GravityModel}-Klasse
Wenn $m$ die Masse des spaceObjects ist, berechnet sich die Energieänderung wie folgt:
Seien $\Delta x$ und $\Delta y$ die Differenzen der Koordinaten zwischen dem spaceObject und dem Gravitationspunkt,
folglich ist $d = \sqrt{\Delta x^2 + \Delta y^2}$ der direkte Abstand. Die Energieänderung in $x$- und $y$-Richtung
ist damit gegeben als (siehe \textit{gravityModel.getEnergy()}): 
\[ \vec{E}_{neu} = E + m \cdot \frac{1}{d} \begin{pmatrix}\Delta x \\ \Delta y\end{pmatrix} \]

Aus dieser Energieänderung lässt sich wiederum die neue Geschwindigkeit des Objekts berechnen (siehe \textit{spaceObject.updateVelocity()}):
\[ \vec{v}_{neu} = \frac{2}{m} \cdot \vec{E}_{neu}\] 

Die Formeln entsprechen ebenfalls nicht ganz der Realität, so wird in der klassischen Physik zwischen Beschleunigung, Energie und Kraft unterschieden,
während wir diese Begriffe etwas unsauber mischen. Die Kraft, mit der sich 2 Objekte - nach Newton - anziehen, beträgt
\[ F = G \cdot \frac{m_1 \cdot m_2}{d^2} \]
und nimmt im Abstand quadratisch ab. Unsere Tests ergaben aber, dass bei quadratisch abnehmender Gravitation, das
Spiel nicht mehr \q{so lustig} war, wie mit linearer Gravitation. Die Objekte wurden in einem gewissen Abstand, wie er
im Spiel durchaus vorkommen könnte, (fast) gar nicht angezogen, die Bahnkurven waren aber in der Nähe der Objekte
unberechenbar und das Spiel somit nicht wirklich spielbar. Deshalb entschieden wir uns, die Anziehungskraft
nur linear abzuschwächen lassen.


\subsubsection{Spieler bewegen / Gravitationspunkt}
% hier spezifisch den punkt bei mausklick


\subsubsection{Level}
%tiles

\textbf{Start und Ziel}
\\

\textbf{Wände}

\subsubsection{- Gegner und Hindernisse}
% Asteroiden und Schwarzes Loch

\subsubsection{Gameover}
Wenn der Spieler mit einem Asteroiden kollidiert oder in ein schwarzes Loch
hineingezogen wird, ist das Spiel vorbei. Wird festgestellt, dass sich die 
Positionen des Spielers und eines anderen Objektes überschneiden, wird eine boolsche
Variable $gameOver$, die beim Start mit $false$ initialisiert wurde, auf $true$ gesetzt.

Vor dem eigentlich Rendering, also wenn alle Änderungen der Spielewelt berechnet wurden
und nur noch alles auf den Bildschirm gezeichnet werden muss, wird auf dieses Flag getestet.
Kollidierte der Spieler also seit dem letzten Rendervorgang, werden nicht mehr alle Objekte
gezeichnet, sondern nur eine Grafik die sich mit \q{GAME OVER} über den Spielbildschirm erstreckt.

Mit der Escape-Taste gelangt man dann wieder zurück ins Hauptmenü. Wird ein neues Level geladen,
wird die $gameOver$-Variable wieder auf $false$ gesetzt, damit das Spiel starten kann.

\subsubsection{Kleine Reibung}


\subsubsection{Zeit}

\subsubsection{Startmenu}

\subsubsection{Spielanleitung}
\inmilestonetwo

\clearpage
\newpage
\section{Entwurf}
\subsection{UML Diagramm}
\vspace{0.3cm}
\includegraphics[height=0.85\textwidth,angle=90]{img/uml.png}

\section{Implementierung}
% Quellcode
\input{quellcode}


\section{Resultate und Testen}
\inmilestonetwo
\section{Diskussion und Ausblick}
\inmilestonetwo




\end{document}
 
